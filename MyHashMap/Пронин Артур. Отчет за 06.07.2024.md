**Домашка:**
Реализовать put, get, remove хэш-таблицы, коллизии решать методом цепочек

---

### Задачи

- [x] - Посмотреть и законспектировать блок про Map и hashCode [Лекция 7. Map, hashcode, компараторы - Тагир Валеев](https://www.youtube.com/watch?v=moFEPxS9gB4)
- [x] - Сделать вторую реализацию (доработка) MyHashMap на Java
- [x] - Добавить тесты, используя JUnit 5

### Реализация

#### Цели
- [x] - Добавить `class Node<K, V>` и сохранять объекты этого класса в массив в методе `put()`
- [x] - Добавить load factor = 0.75 для решения проблемы переполнения массива
- [x] - Реализовать метод `checkResize()` - для проверки переполнения массива и `resize()` - для создания нового массива размером вдвое больше текущего и перезаписи существующего
- [x] -  Переработать методы `put(), get(), remove()`, с учетом добавления, получения и удаления `Node` из массива
- [x] - Разделить классы (`Main` и `Person(для теста)` вынести в отдельные классы. Класс `Node<K, V>` сделать вложенным, внутри класса `MyHashMap`)
- [x] Протестировать методы `put(), get(), remove()` на разных типах данных
- [x] Протестировать `resize()` массива
- [x] Протестировать перезапись `value` по одному и тому же ключу
- [x] Проверка, если в `key и value` передать `Null`
- [x] Проверка коллизии для частного случая, когда по разным ключам вычисляется одинаковый индекс (проверяем записалась ли ссылка на следующую Node)

#### Примерные проблемы
- [x] - Разные значения keys (Вычисляем hash функцию и нормализуем, чтобы индекс не выходил за пределы массива (пока функция сгенерирована IDEA и иногда может давать одинаковый индекс для разных keys))
- [x] - Разные значения values (Generic type для values и значения могут быть разными, даже объектами)
- [x] - Переполнение массива (**Default Load Factor = 0.75**, методом `checkResize()` проверяем, если текущий `size >= array.length * LOAD_FACTOR;` -> нужно делать `resize()` и увеличиваем массив вдвое)
- [x] - Одинаковые значения keys (Решено добавлением `Node<K, V>` -> теперь мы храним не только значения, но и ключи, соответственно можем проверять не существует ли уже этого ключа в мапе)
- [x] - Коллизии (Решено добавлением `Node<K, V>` и теперь в массиве мы храним не сами элементы, а объект `Node` с полями `ключ : значение`)